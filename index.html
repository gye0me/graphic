<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Little Patissier's Dream</title> 
    
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet"> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* ğŸš¨ í°íŠ¸ ë° UI ë°°ê²½ ë³€ê²½ */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #333; 
            font-family: 'Jua', sans-serif;
        }
        canvas { display: block; }
        
        /* ê´€ëŒ ëª¨ë“œ ì»¨íŠ¸ë¡¤ UI */
        .controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            user-select: none;
            text-align: left;
            border: 2px solid #3de6c5; /* ê°•ì¡° í…Œë‘ë¦¬ */
            box-shadow: 0 0 10px rgba(61, 230, 197, 0.7); /* ë¹›ë‚˜ëŠ” íš¨ê³¼ */
        }
        .controls h3 { margin: 0 0 5px 0; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .controls p { margin: 3px 0; }
        .highlight { color: #3de6c5; font-weight: bold; }
        
        /* íŒ”ë ˆíŠ¸ ì»¨í…Œì´ë„ˆ */
        #palette-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: none; 
            padding: 15px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), 0 0 10px #ffaa00; /* ê²Œì„ UIì²˜ëŸ¼ ê°•ì¡° */
            text-align: center;
            border: 3px solid #ffaa00;
        }
        #topping-palette, #cream-palette {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
        }
        .palette-item {
            width: 60px;
            height: 60px;
            border: 4px solid transparent;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            color: #333;
            transition: border-color 0.2s, transform 0.1s;
        }
        .palette-item:hover { border-color: #ffaa00; }
        .palette-item.selected { 
            border-color: #3de6c5; 
            transform: scale(1.05);
            box-shadow: 0 0 5px #3de6c5;
        }
        
        /* ë©”ì‹œì§€ ì°½ */
        #message {
            position: absolute;
            top: 100px; 
            left: 50%;
            transform: translateX(-50%);
            padding: 25px 40px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 15px;
            font-size: 24px;
            z-index: 101;
            display: block; 
            text-align: center;
            line-height: 1.6;
            border: 3px solid #ffaa00;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.7);
        }

        /* ğŸš¨ ì‹¤ì‹œê°„ ì ìˆ˜ ì˜¤ë²„ë ˆì´ ì¶”ê°€ */
        #score-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-size: 30px;
            border-radius: 8px;
            border: 3px solid #ffaa00;
            z-index: 100;
            display: none;
            font-family: 'Jua', sans-serif;
        }
        #score-value {
            color: #3de6c5;
            font-weight: bold;
        }
        
        /* í¬ë¦¼ ë°”ë¥´ê¸° ë¯¸ë‹ˆê²Œì„ í”„ë¡œê·¸ë ˆìŠ¤ ë°” ìŠ¤íƒ€ì¼ */
        #spreading-progress-bar {
            width: 80%;
            height: 20px;
            background-color: #555;
            border-radius: 10px;
            margin: 10px auto 0;
            overflow: hidden;
            border: 2px solid #ccc;
        }
        #spreading-progress-fill {
            height: 100%;
            width: 0%;
            background-color: #3de6c5;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>
    
    <div id="message">
        **Little Patissier's Dream**<br>ì¼€ì´í¬ ì œì‘ ì‹œë®¬ë ˆì´ì…˜ì„ ì‹œì‘í•©ë‹ˆë‹¤!<br>
        <span style="color: #3de6c5;">[Spacebar]</span>ë¥¼ ëˆŒëŸ¬ ë°˜ì£½ ë° ë¯¹ì‹± ê³¼ì •ì„ ì§„í–‰í•˜ì„¸ìš”.
    </div>

    <div id="score-overlay">
        SCORE: <span id="score-value">0</span>
    </div>

    <div id="palette-container">
        <div>ğŸ° ìƒí¬ë¦¼ ìƒ‰ìƒ ì„ íƒ (í´ë¦­ í›„ ì¼€ì´í¬ í´ë¦­)</div>
        <div id="cream-palette">
            <div class="palette-item selected" data-type="cream" data-color="0xffffff" style="background-color: #ffffff;">í°ìƒ‰</div>
            <div class="palette-item" data-type="cream" data-color="0xffc0cb" style="background-color: #ffc0cb;">í•‘í¬</div>
            <div class="palette-item" data-type="cream" data-color="0x5a8d41" style="background-color: #5a8d41;">ë…¹ì°¨</div>
            <div class="palette-item" data-type="cream" data-color="0xffd700" style="background-color: #ffd700;">ê³ êµ¬ë§ˆ</div>
        </div>
        <hr style="border-color: #444; margin: 10px 0;">
        <div>ğŸ“ í† í•‘ ì„ íƒ (í´ë¦­ í›„ ì¼€ì´í¬ í´ë¦­/ë“œë˜ê·¸)</div>
        <div id="topping-palette">
            <div class="palette-item" data-type="strawberry" style="background-color: #ffcccc;">ë”¸ê¸°</div>
            <div class="palette-item" data-type="sprinkle" style="background-color: #e0e0e0;">ìŠ¤í”„ë§í´</div>
            <div class="palette-item" data-type="drizzle" style="background-color: #a0522d;">ì´ˆì½œë¦¿</div>
            <div class="palette-item" data-type="cherry" style="background-color: #ff0000; color: white;">ì²´ë¦¬</div>
            <div class="palette-item" data-type="piping" style="background-color: #ffffff; color: #333; border-color: #3de6c5;">íŒŒì´í•‘</div>
        </div>
    </div>

    <div id="viewing-controls" class="controls" style="display: none;">
        <h3>ğŸ‚ ê´€ëŒ ëª¨ë“œ ì»¨íŠ¸ë¡¤</h3>
        <p><span class="highlight">[P]</span> / <span class="highlight">[O]</span>: ì›ê·¼ / ì§êµ ì¹´ë©”ë¼ ì „í™˜</p>
        <p><span class="highlight">[â†‘] [â†“] [â†] [â†’]</span>: ì¼€ì´í¬ ì´ë™</p>
        <p><span class="highlight">[1]</span> / <span class="highlight">[2]</span>: ì¹´ë©”ë¼ ìœ„ì¹˜ ë³€ê²½</p>
        <p><span class="highlight">[L]</span>: ì¡°ëª… ìƒ‰ìƒ ë³€ê²½</p>
        <p><span class="highlight">[Spacebar]</span>: í† í•‘ íšŒì „/ì •ì§€</p>
        <p><span class="highlight">[C]</span>: ì´›ë¶ˆ ì¼œê¸°/ë„ê¸°</p>
        <hr style="border-color: #444; margin: 5px 0;">
        <p><span class="highlight">[K]</span>: ì¼€ì´í¬ ì „í™˜ (ì œì‘ â†” í…Œë§ˆ)</p>
    </div>

<script>
// í•™ë²ˆ: 20230789
// ì´ë¦„: ë°°í¬ê²¸
// ì‚¬ìš©í•œ Three.js ë°©ë²•: CDN

const h_scr = window.innerWidth;
const v_scr = window.innerHeight;
const viewSize = 10; 
const aspect = h_scr / v_scr;
const moveSpeed = 0.1; 
const CAKE_HEIGHT = 1.0; 

const BASE_ROTATION_SPEED = 0.001;
const TOPPING_ROTATION_SPEED = 0.015;

const scene = new THREE.Scene(); 
scene.background = new THREE.Color(0x555555); // ë°°ê²½ìƒ‰ ì–´ë‘¡ê²Œ ë³€ê²½

// --- ëª¨ë“œ ë³€ìˆ˜ ---
let gameMode = 'MAKING'; 
let makingStep = 0; // 0: ì‹œì‘, 1: ë¯¹ì‹± ì¤‘, 2: ë°˜ì£½ ì™„ë£Œ, 3: êµ½ê¸° ì™„ë£Œ, 4: í¬ë¦¼ í´ë°”ë¥´ê¸° ì™„ë£Œ ëŒ€ê¸°, 5: ì¥ì‹ ëª¨ë“œ
let selectedToppingType = null;
let selectedCreamColor = 0xffffff;

// ğŸš¨ ì ìˆ˜ ë° ë¯¸ë‹ˆê²Œì„ ë³€ìˆ˜ ì¶”ê°€
let score = 0;
let toppingsCount = 0;
let pipingActive = false;
let lastPipingPoint = null;
const MAX_TOPPING_RADIUS = 1.4; 
const PIPING_CREAM_COLOR = 0xffffff; 
const activeSplashMeshes = []; 

// ğŸš¨ í¬ë¦¼ í´ë°”ë¥´ê¸° ë¯¸ë‹ˆê²Œì„ ë³€ìˆ˜
let creamSpreadQuality = 0; 
let spreadingActive = false;
const MAX_SPREAD_COUNT = 20; // 20ë²ˆ í´ë¦­/ë“œë˜ê·¸ë¡œ 100% ë‹¬ì„±
const MAX_SPREAD_TIME = 3000; // 3ì´ˆ ì œí•œ
let spreadTimeoutId = null;

const mouse = new THREE.Vector2();
const raycaster = new THREE.Raycaster();

// --- HTML ìš”ì†Œ ---
const paletteContainer = document.getElementById('palette-container');
const messageElement = document.getElementById('message');
const controlsElement = document.getElementById('viewing-controls');
const scoreOverlay = document.getElementById('score-overlay');


// --- 1. ì¹´ë©”ë¼ ì„¤ì • ---
const perspectiveCamera = new THREE.PerspectiveCamera(75, h_scr / v_scr, 0.1, 1000);
perspectiveCamera.position.set(0, 2.0, 4); 

const orthographicCamera = new THREE.OrthographicCamera(
    viewSize * aspect / -2, viewSize * aspect / 2, viewSize / 2, viewSize / -2, 0.1, 100
);
orthographicCamera.position.set(0, 5, 0);

let currentCamera = perspectiveCamera;
currentCamera.lookAt(0, 0, 0); 

// ë Œë”ëŸ¬ ì„¤ì •
const renderer = new THREE.WebGLRenderer({ antialias: true });
document.body.appendChild(renderer.domElement);
renderer.setSize(h_scr, v_scr);
renderer.shadowMap.enabled = true; 
renderer.shadowMap.type = THREE.PCFSoftShadowMap; 


// --- 2. ì¡°ëª… ì„¤ì • ---
const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); 
scene.add(ambientLight);

const spotLight = new THREE.SpotLight(0xffffff, 2.0, 10, Math.PI * 0.15, 0.5, 2); 
spotLight.position.set(2, 4, 3);
spotLight.castShadow = true;
spotLight.shadow.mapSize.width = 1024;
spotLight.shadow.mapSize.height = 1024;
scene.add(spotLight);

const frontLight = new THREE.DirectionalLight(0xffffff, 0.5);
frontLight.position.set(0, 3, 5);
frontLight.castShadow = true;
scene.add(frontLight);

const lightColors = [0xffffff, 0xf183f3, 0x3de6c5, 0xffa500]; 
let currentLightColorIndex = 0;

// --- 3. ì£¼ë°© í™˜ê²½ ì„¤ì • (ê¸°ì¡´ ì½”ë“œ ìœ ì§€) ---
const kitchenGroup = new THREE.Group();
scene.add(kitchenGroup);

const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
const wall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
wall.rotation.y = Math.PI;
wall.position.set(0, 5, -5);
wall.receiveShadow = true;
kitchenGroup.add(wall);

const counterMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 }); 
const counter = new THREE.Mesh(new THREE.BoxGeometry(5, 1, 5), counterMaterial);
counter.position.set(0, -0.5, 0);
counter.receiveShadow = true;
kitchenGroup.add(counter);

const gridHelper = new THREE.GridHelper( 5, 5, 0x444444, 0x888888 );
scene.add( gridHelper );


// --- 4. ì¼€ì´í¬ ì œì‘/ëª¨ë¸ë§ ìš”ì†Œ ---

// ğŸš¨ í…ìŠ¤ì²˜ ì œê±° ë° Material ê°œì„ 
const bakedMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xe0b28a, 
    roughness: 0.8, 
    metalness: 0.1 
}); 
const creamMaterial = new THREE.MeshStandardMaterial({ 
    color: selectedCreamColor, 
    roughness: 0.5, 
    metalness: 0.01 
}); 
const strawberryMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 50 }); 
const chocolateMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513, shininess: 20 }); 
const macaronMaterial = new THREE.MeshPhongMaterial({ color: 0xe0e0e0, shininess: 80 }); 
const beanMaterial = new THREE.MeshPhongMaterial({ color: 0x803333, shininess: 20 }); 

// ğŸš¨ íŒŒì´í•‘ í¬ë¦¼ ì¬ì§ˆ
const pipingMaterial = new THREE.MeshStandardMaterial({ 
    color: PIPING_CREAM_COLOR, 
    roughness: 0.5, 
    metalness: 0.01 
});


// 4-1. ë¯¹ì‹± ìš©ê¸° (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
const bowlGroup = new THREE.Group();
bowlGroup.position.y = 1.0;
scene.add(bowlGroup);
const bowl = new THREE.Mesh(
    new THREE.CylinderGeometry(2.0, 1.5, 1.0, 32, 1, true),
    new THREE.MeshStandardMaterial({ color: 0xcccccc, transparent: true, opacity: 0.3, side: THREE.BackSide })
);
bowl.position.y = 0.5;
bowlGroup.add(bowl);
const mixingContent = new THREE.Group();
const egg = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
const flour = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3), new THREE.MeshBasicMaterial({ color: 0xffffff }));
for(let i=0; i<30; i++) {
    const item = i % 5 === 0 ? egg.clone() : flour.clone();
    item.position.set((Math.random() - 0.5) * 2, Math.random() * 0.5, (Math.random() - 0.5) * 2);
    mixingContent.add(item);
}
mixingContent.position.y = 0.5;
mixingContent.visible = false;
bowlGroup.add(mixingContent);


// 4-2. ì¼€ì´í¬ ë³¸ì²´ (1ì¸µ)
const cakeGroup = new THREE.Group();
cakeGroup.position.y = 0.5; 
cakeGroup.visible = false; 
scene.add(cakeGroup);

const cakeLayerGeometry = new THREE.CylinderGeometry(1.5, 1.5, CAKE_HEIGHT, 32);

// ë¹µ ì¸µ
const cakeBody = new THREE.Mesh(cakeLayerGeometry, bakedMaterial);
cakeBody.position.y = 0; 
cakeBody.castShadow = true;
cakeBody.receiveShadow = true;
cakeGroup.add(cakeBody);

// ìƒí¬ë¦¼ ë ˆì´ì–´ (ì¼€ì´í¬ ìœ—ë©´)
const creamTop = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.1, 32), creamMaterial);
creamTop.position.y = CAKE_HEIGHT * 0.5 + 0.05; 
creamTop.castShadow = true;
creamTop.receiveShadow = true;
cakeGroup.add(creamTop);


// 4-3. í† í•‘ ê·¸ë£¹
const customToppingGroup = new THREE.Group();
customToppingGroup.position.y = 0.5 * CAKE_HEIGHT + 0.1;
cakeGroup.add(customToppingGroup);

const themeToppingGroup = new THREE.Group();
themeToppingGroup.position.y = 0.5 * CAKE_HEIGHT + 0.1;
cakeGroup.add(themeToppingGroup);
themeToppingGroup.visible = false; 

// --- ì´›ë¶ˆ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€) ---
const mainCandleGroup = new THREE.Group();
mainCandleGroup.position.set(0, CAKE_HEIGHT * 0.5 + 0.15, 0); 
cakeGroup.add(mainCandleGroup);

const candleBody = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.6, 16), new THREE.MeshPhongMaterial({ color: 0xffa500, shininess: 50 })); 
candleBody.position.y = 0.3; 
mainCandleGroup.add(candleBody);
const flame = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffc800, transparent: true, opacity: 0.8 })); 
flame.position.y = 0.65; 
mainCandleGroup.add(flame);
const candleLight = new THREE.PointLight(0xffaa00, 1.0, 2); 
candleLight.position.y = 0.7; 
mainCandleGroup.add(candleLight);

let isCandleOn = true;
candleLight.visible = isCandleOn;
flame.visible = isCandleOn;


// 4-4. í…Œë§ˆë³„ í† í•‘ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
const themeMeshes = new THREE.Group(); 
themeToppingGroup.add(themeMeshes); 

const strawberryMeshes = [];
[[1.0, 0], [-1.0, 0], [0.7, 0.7], [-0.7, 0.7], [0, -1.0]].forEach(pos => {
    const s = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), strawberryMaterial);
    s.position.set(pos[0], 0, pos[1]);
    themeMeshes.add(s);
    strawberryMeshes.push(s);
});

const chocolateDrizzle = new THREE.Mesh(new THREE.TorusKnotGeometry(1.3, 0.08, 64, 8, 2, 3), chocolateMaterial);
chocolateDrizzle.position.set(0, -0.15, 0); 
chocolateDrizzle.scale.set(1.0, 0.5, 1.0);
chocolateDrizzle.rotation.x = Math.PI / 2;
themeMeshes.add(chocolateDrizzle);

const sweetPotatoMeshes = [];
const sweetPotatoGeometry = new THREE.SphereGeometry(0.3, 16, 16);
[[0.5, 0.5, 0.8], [-0.5, 0.5, 1.2], [0, -0.7, 1.0], [1.0, -0.3, 0.9]].forEach(params => {
    const m = new THREE.Mesh(sweetPotatoGeometry, new THREE.MeshPhongMaterial({ color: 0xd7af70, shininess: 30 }));
    m.position.set(params[0], 0.1 + params[2] * 0.15, params[1]);
    m.scale.y = params[2];
    themeMeshes.add(m);
    sweetPotatoMeshes.push(m);
});

const matchaMeshes = [];
const macaronGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 32);
[['macaron', 1.2, 0.5], ['macaron', -1.2, 0.5], ['macaron', 0.8, -0.9], 
 ['bean', 0.3, 0.9], ['bean', -0.4, 0.8], ['bean', 0.6, 0.1], ['bean', -0.8, -0.2], ['bean', 0.1, -0.6]]
.forEach(params => {
    let element;
    if (params[0] === 'macaron') {
        element = new THREE.Mesh(macaronGeometry, macaronMaterial);
        element.rotation.x = Math.PI / 2; 
    } else { 
        element = new THREE.Mesh(new THREE.SphereGeometry(0.1, 12, 12), beanMaterial);
    }
    element.position.set(params[1], 0.05, params[2]);
    themeMeshes.add(element);
    matchaMeshes.push(element);
});

const themeSprinkleMeshes = [];
const sprinkleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.1, 8);
const sprinkleColors = [0xffa500, 0x00ff00, 0x0000ff, 0xff00ff, 0xffff00]; 
for (let i = 0; i < 50; i++) { 
    const material = new THREE.MeshPhongMaterial({ shininess: 100 });
    const sprinkle = new THREE.Mesh(sprinkleGeometry, material);
    const radius = Math.random() * 1.3;
    const angle = Math.random() * Math.PI * 2;
    sprinkle.position.set(Math.cos(angle) * radius, 0.05, Math.sin(angle) * radius);
    sprinkle.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
    themeMeshes.add(sprinkle);
    themeSprinkleMeshes.push(sprinkle);
}
themeMeshes.children.forEach(m => m.visible = false); 


// ë°”ë‹¥
const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), new THREE.MeshLambertMaterial({ color: 0xc8c8c8, side: THREE.DoubleSide }));
floor.rotation.x = -Math.PI / 2; 
floor.position.y = -1; 
floor.receiveShadow = true;
scene.add(floor);


// --- 5. ì¼€ì´í¬ ì¢…ë¥˜ ì •ì˜ ë° ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€) ---
const CAKE_THEMES = [
    { body: 0x4a2c2a, cream: 0x7b3f00, topping: 'chocolate' }, 
    { body: 0xffe0e0, cream: 0xffffff, topping: 'strawberry' }, 
    { body: 0xc8a2c8, cream: 0xffd700, topping: 'sweetpotato' }, 
    { body: 0xc0c8a0, cream: 0x5a8d41, topping: 'matcha' } 
];
let currentThemeIndex = -1; 
let isToppingRotating = true;


function updateCakeTheme() {
    if (currentThemeIndex === -1) { 
        cakeBody.material = bakedMaterial;
        cakeBody.material.color.set(0xe0b28a); 
        
        creamTop.material.color.set(selectedCreamColor); 
        
        customToppingGroup.visible = true;
        themeToppingGroup.visible = false;
        
    } else {
        const theme = CAKE_THEMES[currentThemeIndex];
        const toppingType = theme.topping;
        
        cakeBody.material.color.set(theme.body);
        creamTop.material.color.set(theme.cream);
        
        customToppingGroup.visible = false;
        themeToppingGroup.visible = true;
        
        themeMeshes.children.forEach(m => m.visible = false);
        strawberryMeshes.forEach(s => s.visible = toppingType === 'strawberry');
        chocolateDrizzle.visible = toppingType === 'chocolate';
        sweetPotatoMeshes.forEach(s => s.visible = toppingType === 'sweetpotato');
        matchaMeshes.forEach(s => s.visible = toppingType === 'matcha');
        
        themeSprinkleMeshes.forEach((s, i) => {
            s.visible = true;
            const material = s.material;
            if (toppingType === 'matcha') material.color.set(Math.random() > 0.5 ? 0x90ee90 : 0xffffff);
            else if (toppingType === 'sweetpotato') material.color.set(0x8b4513);
            else material.color.set(sprinkleColors[i % sprinkleColors.length]);
            material.needsUpdate = true;
        });
    }

    cakeBody.material.needsUpdate = true;
    creamTop.material.needsUpdate = true;
}


// --- 6. ëª¨ë“œ ì „í™˜ ë° ì œì‘ ë‹¨ê³„ ë¡œì§ ---

// ğŸš¨ ì ìˆ˜ í‘œì‹œ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateScoreDisplay() {
    const finalScore = Math.max(0, Math.round(score + (toppingsCount * 2)));
    const scoreElement = document.getElementById('score-value');
    if (scoreElement) {
        scoreElement.textContent = finalScore;
    }
}

function setGameMode(mode) {
    gameMode = mode;
    messageElement.style.display = 'none';
    paletteContainer.style.display = 'none';
    controlsElement.style.display = 'none';
    scoreOverlay.style.display = 'none';
    bowlGroup.visible = false;
    cakeGroup.visible = false;
    
    mainCandleGroup.visible = true;
    candleLight.visible = isCandleOn;
    flame.visible = isCandleOn;
    
    // ë¯¸ë‹ˆê²Œì„ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
    window.removeEventListener('mousedown', onSpreadingAction);

    if (mode === 'MAKING') {
        bowlGroup.visible = true;
        cakeBody.visible = false;
        creamTop.visible = false;
        messageElement.innerHTML = `**Little Patissier's Dream**<br>ì¼€ì´í¬ ì œì‘ ì‹œë®¬ë ˆì´ì…˜ì„ ì‹œì‘í•©ë‹ˆë‹¤!<br><span style="color: #3de6c5;">[Spacebar]</span>ë¥¼ ëˆŒëŸ¬ ë°˜ì£½ ë° ë¯¹ì‹± ê³¼ì •ì„ ì§„í–‰í•˜ì„¸ìš”.`;
        messageElement.style.display = 'block';
        makingStep = 0;
        mixingContent.visible = false;
        mixingContent.children.forEach(m => m.material.color.set(m.geometry.type === 'SphereGeometry' ? 0xffaa00 : 0xffffff)); 
        
    } else if (mode === 'DECORATING') {
        cakeGroup.visible = true;
        cakeBody.visible = true;
        creamTop.visible = true;

        // ğŸš¨ ì ìˆ˜ ì´ˆê¸°í™” ë° UI ì—…ë°ì´íŠ¸
        score = 0;
        toppingsCount = 0;
        customToppingGroup.children.length = 0; 
        updateScoreDisplay();
        
        // ğŸš¨ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸: Spacebar ì¶”ê°€
        messageElement.innerHTML = `**ì¥ì‹ ëª¨ë“œ (DECORATING)**<br>íŒ”ë ˆíŠ¸ì—ì„œ <span class="highlight">ìƒí¬ë¦¼ ìƒ‰ìƒ</span> ë˜ëŠ” <span class="highlight">í† í•‘</span>ì„ ì„ íƒ í›„ ì¼€ì´í¬ ìœ—ë©´ì„ <span class="highlight">í´ë¦­/ë“œë˜ê·¸</span>í•˜ì„¸ìš”.<br>ì™„ë£Œ í›„ <span style="color: #3de6c5;">[Enter]</span> ë˜ëŠ” <span style="color: #3de6c5;">[Spacebar]</span> í‚¤ë¥¼ ëˆ„ë¥´ì„¸ìš”.`;
        messageElement.style.display = 'block';
        paletteContainer.style.display = 'block';
        scoreOverlay.style.display = 'block'; // ì ìˆ˜ ì˜¤ë²„ë ˆì´ í‘œì‹œ
        customToppingGroup.visible = true;
        themeToppingGroup.visible = false;
        
        // DECORATING ëª¨ë“œ ì§„ì… ì‹œ ìƒí¬ë¦¼ ìƒ‰ìƒì„ í°ìƒ‰ìœ¼ë¡œ ì´ˆê¸°í™”
        creamTop.material.color.set(0xffffff); 
        selectedCreamColor = 0xffffff;
        
        document.querySelectorAll('.palette-item').forEach(i => i.classList.remove('selected'));
        document.querySelector('.palette-item[data-color="0xffffff"]').classList.add('selected');

    } else if (mode === 'VIEWING') {
        cakeGroup.visible = true;
        cakeBody.visible = true;
        creamTop.visible = true;

        controlsElement.style.display = 'block';
        
        selectedCreamColor = creamTop.material.color.getHex(); 
        
        currentThemeIndex = -1; 
        updateCakeTheme();

        const finalScore = Math.max(0, Math.round(score + (toppingsCount * 2))); 
        messageElement.innerHTML = `â­ ì¼€ì´í¬ ì™„ì„±! ìµœì¢… ì ìˆ˜: <span style="color: #ffaa00; font-size: 1.5em;">${finalScore}</span>ì ! â­<br> [Enter]ë¥¼ ëˆŒëŸ¬ ê´€ëŒ ëª¨ë“œë¥¼ ì‹œì‘í•˜ì„¸ìš”.`;
        messageElement.style.display = 'block';
        setTimeout(() => messageElement.style.display = 'none', 3000); 
    }
}


// ğŸš¨ í¬ë¦¼ í´ë°”ë¥´ê¸° ë¯¸ë‹ˆê²Œì„ ì™„ë£Œ í•¨ìˆ˜
function finishSpreadingGame() {
    if (!spreadingActive) return;
    
    spreadingActive = false;
    clearTimeout(spreadTimeoutId); // íƒ€ì´ë¨¸ ì·¨ì†Œ
    
    // í”„ë¡œê·¸ë ˆìŠ¤ ë°” ì œê±°
    const progressBar = document.getElementById('spreading-progress-bar');
    if (progressBar) progressBar.remove();
    
    creamTop.visible = true; // í¬ë¦¼ ë®ê¸°
    window.removeEventListener('mousedown', onSpreadingAction);

    const finalQuality = Math.min(100, Math.round((creamSpreadQuality / MAX_SPREAD_COUNT) * 100));
    
    let scoreBonus = 0;
    let messageText;
    const finalColor = new THREE.Color(0xffffff);
    
    if (finalQuality >= 90) {
        scoreBonus = 50;
        messageText = `âœ¨ **ëŒ€ì„±ê³µ!** í¬ë¦¼ì´ ì™„ë²½í•˜ê²Œ ë°œë ¸ìŠµë‹ˆë‹¤! (+${scoreBonus}ì  ë³´ë„ˆìŠ¤)`;
    } else if (finalQuality >= 50) {
        scoreBonus = 20;
        messageText = `âœ… **ì„±ê³µ!** í¬ë¦¼ì´ ì˜ ë°œë ¸ìŠµë‹ˆë‹¤. (+${scoreBonus}ì  ë³´ë„ˆìŠ¤)`;
    } else {
        scoreBonus = -30;
        messageText = `âŒ **ì‹¤íŒ¨!** í¬ë¦¼ì´ ìš¸í‰ë¶ˆí‰í•©ë‹ˆë‹¤! (-30ì  í˜ë„í‹°)`;
        finalColor.set(0xcccccc); // ì‹¤íŒ¨ í˜ë„í‹°ë¡œ í¬ë¦¼ ìƒ‰ìƒì„ íšŒìƒ‰ìœ¼ë¡œ
    }
    
    // ìµœì¢… í’ˆì§ˆì— ë”°ë¼ í¬ë¦¼ ìƒ‰ìƒ ê²°ì •
    creamTop.material.color.set(finalColor);
    
    score += scoreBonus;
    updateScoreDisplay();

    messageElement.innerHTML = `${messageText}<br><span style="color: #3de6c5;">[Spacebar]</span>ë¥¼ ëˆŒëŸ¬ ì¥ì‹ ëª¨ë“œì— ì§„ì…í•˜ì„¸ìš”.`;
    messageElement.style.display = 'block';
    
    makingStep = 4; // Spacebar ì…ë ¥ì„ ê¸°ë‹¤ë¦¬ê¸° ìœ„í•´ makingStepì„ 4ë¡œ ì„¤ì •
}

// ğŸš¨ í¬ë¦¼ í´ë°”ë¥´ê¸° ì•¡ì…˜ í•¨ìˆ˜
function onSpreadingAction() {
    if (gameMode !== 'MAKING' || !spreadingActive) return;
    
    if (creamSpreadQuality < MAX_SPREAD_COUNT) {
        creamSpreadQuality++; 
        
        // í’ˆì§ˆì— ë”°ë¼ ì¼€ì´í¬ í‘œë©´ ìƒ‰ìƒì„ ë³€ê²½í•˜ì—¬ í¬ë¦¼ì´ ë®ì´ëŠ” ê²ƒì„ ì‹œê°ì ìœ¼ë¡œ í‘œí˜„
        const mixColor = new THREE.Color(0xe0b28a).lerp(new THREE.Color(0xffffff), creamSpreadQuality / MAX_SPREAD_COUNT);
        cakeBody.material.color.set(mixColor.getHex());
        
        // í”„ë¡œê·¸ë ˆìŠ¤ ë°” ì—…ë°ì´íŠ¸
        const progressFill = document.getElementById('spreading-progress-fill');
        if (progressFill) {
            progressFill.style.width = `${(creamSpreadQuality / MAX_SPREAD_COUNT) * 100}%`;
        }

        if (creamSpreadQuality >= MAX_SPREAD_COUNT) {
            finishSpreadingGame();
        }
    }
}


function advanceMakingStep() {
    makingStep++;

    if (makingStep === 1) { 
        mixingContent.visible = true;
        messageElement.innerHTML = `**ë¯¹ì‹±!** ê³„ë€, ë°€ê°€ë£¨, ì„¤íƒ•ì„ ë„£ê³  ìˆìŠµë‹ˆë‹¤.<br> <span style="color: #3de6c5;">[Spacebar]</span>ë¡œ ë°˜ì£½ì„ ì™„ë£Œí•˜ì„¸ìš”.`;
    } else if (makingStep === 2) { 
        mixingContent.children.forEach(m => m.material.color.set(0xf4d03f));
        messageElement.innerHTML = `**ë°˜ì£½ ì™„ë£Œ!** ì˜¤ë¸ì— êµ¬ìš¸ ì¤€ë¹„ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.<br> <span style="color: #3de6c5;">[Spacebar]</span>ë¡œ êµ½ê¸°ë¥¼ ì‹œì‘í•˜ì„¸ìš”.`;
    } else if (makingStep === 3) { 
        bowlGroup.visible = false;
        cakeGroup.visible = true;
        cakeBody.visible = true;
        creamTop.visible = true;
        cakeBody.material = bakedMaterial; 
        cakeBody.material.color.set(0xe0b28a); 
        
        // ğŸš¨ í¬ë¦¼ í´ë°”ë¥´ê¸° ë¯¸ë‹ˆê²Œì„ ì‹œì‘ ì¤€ë¹„ (makingStep=3ì—ì„œ ë‹¤ìŒ Spacebar ì…ë ¥ì„ ê¸°ë‹¤ë¦¼)
        messageElement.innerHTML = `**êµ½ê¸° ì™„ë£Œ ë° ì ì¸µ!** ì´ì œ í¬ë¦¼ì„ ë°”ë¦…ë‹ˆë‹¤.<br> <span style="color: #3de6c5;">[Spacebar]</span>ë¥¼ ëˆŒëŸ¬ **í¬ë¦¼ í´ë°”ë¥´ê¸° ë¯¸ë‹ˆê²Œì„**ì„ ì‹œì‘í•˜ì„¸ìš”.`;

    } else if (makingStep === 4) { 
        // ğŸš¨ í¬ë¦¼ í´ë°”ë¥´ê¸° ë¯¸ë‹ˆê²Œì„ ì‹œì‘
        creamTop.visible = false; 
        cakeBody.material.color.set(0xe0b28a); // í¬ë¦¼ ë°”ë¥´ê¸° ì‹œì‘ ì‹œ ë¹µ ìƒ‰ìƒìœ¼ë¡œ ì´ˆê¸°í™”

        messageElement.innerHTML = `**[í¬ë¦¼ í´ë°”ë¥´ê¸° ë¯¸ë‹ˆê²Œì„]**<br>ì¼€ì´í¬ ëª¸í†µì„ ë¹ ë¥´ê²Œ <span style="color: #ffaa00;">í´ë¦­/ë“œë˜ê·¸</span>í•´ì„œ í¬ë¦¼ì„ í´ë°”ë¥´ì„¸ìš”! <span style="color: #3de6c5;">3ì´ˆ ì œí•œ!</span>
        <div id="spreading-progress-bar"><div id="spreading-progress-fill"></div></div>`;
        messageElement.style.display = 'block';
        
        creamSpreadQuality = 0; 
        spreadingActive = true;
        
        // 3ì´ˆ í›„ ê°•ì œ ì¢…ë£Œ (Time Out)
        spreadTimeoutId = setTimeout(() => {
            if (spreadingActive) finishSpreadingGame();
        }, MAX_SPREAD_TIME);
        
        window.addEventListener('mousedown', onSpreadingAction);
        
    } else if (makingStep === 5) { // ì¥ì‹ ëª¨ë“œ ì§„ì…
        setGameMode('DECORATING');
    }
}


window.addEventListener('keydown', (e) => {
    // ğŸš¨ k ë³€ìˆ˜ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ë˜, SpacebarëŠ” e.codeë¡œë„ ì²´í¬í•˜ì—¬ ì•ˆì •ì„±ì„ ë†’ì…ë‹ˆë‹¤.
    const k = e.key.toLowerCase(); 
    const isSpace = (k === ' ' || e.code === 'Space');
    
    // ì œì‘ ëª¨ë“œ (MAKING) ì»¨íŠ¸ë¡¤
    if (gameMode === 'MAKING' && isSpace) { 
        
        // 1. ë¯¸ë‹ˆê²Œì„ ì™„ë£Œ í›„ ì¥ì‹ ëª¨ë“œ ì§„ì… (Step 4 -> 5)
        if (makingStep === 4 && !spreadingActive) { 
            makingStep = 5;
            advanceMakingStep();
            e.preventDefault(); 
            return;
        } 
        
        // 2. ì¼ë°˜ ì œì‘ ë‹¨ê³„ ì§„í–‰ (Step 0, 1, 2, 3 -> 1, 2, 3, 4)
        else if (makingStep < 4) {
            advanceMakingStep();
            e.preventDefault(); 
            return;
        }
    }

    // ì¥ì‹ ëª¨ë“œ (DECORATING) ì»¨íŠ¸ë¡¤
    const isEnterOrSpace = (k === 'enter' || isSpace);
    if (gameMode === 'DECORATING' && isEnterOrSpace) {
        setGameMode('VIEWING');
        e.preventDefault(); // Spacebar/Enter ê¸°ë³¸ ë™ì‘ ë°©ì§€
        return;
    }
    
    // 3. ê´€ëŒ ëª¨ë“œ (VIEWING) ì»¨íŠ¸ë¡¤
    if (gameMode !== 'VIEWING') return;

    if (k === 'k') {
        if (currentThemeIndex === -1) { 
            selectedCreamColor = creamTop.material.color.getHex(); 
            currentThemeIndex = 0; 
        } else {
            currentThemeIndex++;
            if (currentThemeIndex >= CAKE_THEMES.length) {
                currentThemeIndex = -1; 
            }
        }
        updateCakeTheme();
    }
    
    if (k === 'l') {
        currentLightColorIndex = (currentLightColorIndex + 1) % lightColors.length;
        const newColor = lightColors[currentLightColorIndex];
        spotLight.color.set(newColor);
        frontLight.color.set(newColor); 
        spotLight.intensity = (currentLightColorIndex === 0) ? 2.0 : 1.5;
    }

    if (k === '1' || k === '2') {
        const targetPosition = new THREE.Vector3();
        cakeGroup.getWorldPosition(targetPosition); 
        
        if (k === '1') { 
            perspectiveCamera.position.set(targetPosition.x + 4, targetPosition.y + 1, targetPosition.z);
        } else if (k === '2') { 
            perspectiveCamera.position.set(targetPosition.x, targetPosition.y + 3, targetPosition.z + 5);
        }

        currentCamera = perspectiveCamera;
        currentCamera.lookAt(targetPosition); 
        currentCamera.updateProjectionMatrix();
        return;
    }

    if (k === 'p') currentCamera = perspectiveCamera; 
    else if (k === 'o') currentCamera = orthographicCamera; 
    currentCamera.updateProjectionMatrix();

    if (isSpace) {
        isToppingRotating = !isToppingRotating;
        e.preventDefault();
    }

    if (k === 'c') {
        isCandleOn = !isCandleOn;
        candleLight.visible = isCandleOn;
        flame.visible = isCandleOn;
    }

    if (e.key.startsWith('Arrow')) e.preventDefault();
});


// --- 7. ì¥ì‹ ëª¨ë“œ í´ë¦­ ë° íŒ”ë ˆíŠ¸ ë¡œì§ (íŒŒì´í•‘ ì‹œë®¬ë ˆì´ì…˜ ë° ì •êµí™”ëœ ë°°ì¹˜) ---

document.querySelectorAll('.palette-item').forEach(item => {
    item.addEventListener('click', () => {
        if (gameMode !== 'DECORATING') return;
        
        document.querySelectorAll('.palette-item').forEach(i => i.classList.remove('selected'));
        item.classList.add('selected');
        
        const type = item.dataset.type;
        if (type === 'cream') {
            selectedToppingType = null;
            selectedCreamColor = parseInt(item.dataset.color);
            pipingMaterial.color.set(selectedCreamColor); 
        } else {
            selectedToppingType = type;
            selectedCreamColor = 0; 
        }
    });
});


window.addEventListener('mousedown', onMouseDown);
window.addEventListener('mousemove', onMouseMove);
window.addEventListener('mouseup', onMouseUp);


// ğŸš¨ íŒŒì´í•‘ ì¡°ê° ìƒì„± í•¨ìˆ˜ (ì›ë¿” ëª¨ì–‘)
function createPipingSegment(x, y, z) {
    const distance = new THREE.Vector2(x, z).length();
    if (distance > MAX_TOPPING_RADIUS) return; 

    // ğŸš¨ ì›ë¿”(ConeGeometry)ì„ ì‚¬ìš©í•˜ì—¬ íŒŒì´í•‘ í¬ë¦¼ ëª¨ì–‘ ì‹œë®¬ë ˆì´ì…˜
    const pipingGeometry = new THREE.ConeGeometry(0.06, 0.12, 16); 
    pipingGeometry.translate(0, 0.06, 0); 
    
    const newTopping = new THREE.Mesh(pipingGeometry, pipingMaterial.clone());
    newTopping.position.set(x, 0.05, z); 
    newTopping.rotation.y = Math.random() * Math.PI * 2; 
    
    newTopping.castShadow = true;
    newTopping.name = 'piping_segment';
    customToppingGroup.add(newTopping);
    
    toppingsCount++;
    
    // ğŸš¨ ìŠ¤í”Œë˜ì‹œ ì´ë²¤íŠ¸ ì¶”ê°€
    activeSplashMeshes.push({ mesh: newTopping, scale: 1.0, timer: 0, duration: 30 });
    
    // ğŸš¨ ì ìˆ˜ ì‹œìŠ¤í…œ: ì¤‘ì•™ì—ì„œ ë„ˆë¬´ ë²—ì–´ë‚œ íŒŒì´í•‘ì— ëŒ€í•´ í˜ë„í‹°
    if (distance > 1.0) { 
        score -= 0.1;
    } else {
        score += 0.05;
    }
    updateScoreDisplay();
}

function onMouseDown(event) {
    if (gameMode !== 'DECORATING' && gameMode !== 'MAKING') { // ë¯¸ë‹ˆê²Œì„ ì¤‘ì—ë„ í´ë¦­ ì´ë²¤íŠ¸ ì²˜ë¦¬
        return;
    }
    
    // ğŸš¨ í¬ë¦¼ í´ë°”ë¥´ê¸° ë¯¸ë‹ˆê²Œì„ ì²˜ë¦¬
    if (spreadingActive) {
        onSpreadingAction(event);
        return;
    }
    
    if (gameMode !== 'DECORATING') return;
    
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, currentCamera);
    const intersects = raycaster.intersectObject(creamTop); 
    
    if (intersects.length > 0) {
        if (selectedToppingType === 'piping') {
            pipingActive = true;
            const point = intersects[0].point;
            lastPipingPoint = point;
            createPipingSegment(point.x, point.y, point.z);
        } else {
            onDecoratingClick(event);
        }
    }
}

function onMouseMove(event) {
    if (gameMode !== 'DECORATING' || !pipingActive) return;

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, currentCamera);
    const intersects = raycaster.intersectObject(creamTop); 

    if (intersects.length > 0) {
        const point = intersects[0].point;
        if (lastPipingPoint && point.distanceTo(lastPipingPoint) > 0.08) { 
            createPipingSegment(point.x, point.y, point.z);
            lastPipingPoint = point;
        }
    }
}

function onMouseUp(event) {
    if (gameMode !== 'DECORATING') return;
    pipingActive = false;
    lastPipingPoint = null;
}


function onDecoratingClick(event) { // ì¼ë°˜ í† í•‘ ë° ìƒ‰ìƒ ë³€ê²½ ì „ìš©
    // ğŸš¨ ì´ í•¨ìˆ˜ëŠ” onMouseDownì—ì„œ í˜¸ì¶œë˜ë„ë¡ ë³€ê²½ë˜ì—ˆìœ¼ë©°, ì§ì ‘ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆëŠ” ì œê±°ë¨
    if (gameMode !== 'DECORATING' || selectedToppingType === 'piping') return;
    
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, currentCamera);
    
    const intersects = raycaster.intersectObject(creamTop); 
    
    if (intersects.length > 0) {
        if (selectedCreamColor) {
            creamTop.material.color.set(selectedCreamColor);
            creamTop.material.needsUpdate = true;
            
        } else if (selectedToppingType) {
            const point = intersects[0].point;
            const distance = new THREE.Vector2(point.x, point.z).length();
            
            if (distance <= MAX_TOPPING_RADIUS) { 
                let newTopping;

                if (selectedToppingType === 'drizzle') {
                    if (customToppingGroup.children.some(c => c.name === 'drizzle')) return; 
                    newTopping = new THREE.Mesh(new THREE.TorusKnotGeometry(1.3, 0.08, 64, 8, 2, 3), chocolateMaterial);
                    newTopping.position.set(0, -0.15, 0); 
                    newTopping.scale.set(1.0, 0.5, 1.0);
                    newTopping.rotation.x = Math.PI / 2;
                    newTopping.name = 'drizzle';
                } else if (selectedToppingType === 'strawberry') {
                    const isTooClose = customToppingGroup.children.some(c => 
                        c.name !== 'drizzle' && c.position.distanceTo(new THREE.Vector3(point.x, 0.05, point.z)) < 0.4
                    );
                    if (isTooClose) {
                        messageElement.innerHTML = `<span style="color: red;">ë„ˆë¬´ ê°€ê¹ìŠµë‹ˆë‹¤!</span> ê°„ê²©ì„ ë‘ê³  ë°°ì¹˜í•˜ì„¸ìš”.`;
                        messageElement.style.display = 'block';
                        setTimeout(() => messageElement.style.display = 'none', 1000);
                        return;
                    }
                    
                    newTopping = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), strawberryMaterial);
                    newTopping.position.set(point.x, 0.05, point.z);
                    score += 5; 
                } else if (selectedToppingType === 'sprinkle') {
                    const color = sprinkleColors[Math.floor(Math.random() * sprinkleColors.length)];
                    const material = new THREE.MeshPhongMaterial({ color: color, shininess: 100 });
                    newTopping = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.1, 8), material);
                    newTopping.position.set(point.x, 0.05, point.z);
                    newTopping.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    score += 0.5;
                } else if (selectedToppingType === 'cherry') {
                    if (distance > 0.5) {
                         messageElement.innerHTML = `<span style="color: red;">ì²´ë¦¬ëŠ” ì¤‘ì•™ì—!</span> ì¤‘ì•™ 50cm ë°˜ê²½ ë‚´ì— ë°°ì¹˜í•˜ì„¸ìš”.`;
                         messageElement.style.display = 'block';
                         setTimeout(() => messageElement.style.display = 'none', 1000);
                         return;
                    }
                    newTopping = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), new THREE.MeshPhongMaterial({ color: 0xcc0000, shininess: 50 }));
                    newTopping.position.set(point.x, 0.05, point.z);
                    const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8), new THREE.MeshBasicMaterial({ color: 0x442200 }));
                    stem.position.y = 0.1;
                    newTopping.add(stem);
                    score += 10; 
                }
                
                if (newTopping) {
                    newTopping.castShadow = true;
                    customToppingGroup.add(newTopping);
                    toppingsCount++;
                    updateScoreDisplay(); 
                    
                    if (selectedToppingType !== 'drizzle') {
                        activeSplashMeshes.push({ mesh: newTopping, scale: 1.0, timer: 0, duration: 30 });
                    }
                }
            } else {
                 messageElement.innerHTML = `<span style="color: red;">ì¼€ì´í¬ ë°–ì—ëŠ” ë°°ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!</span>`;
                 messageElement.style.display = 'block';
                 setTimeout(() => messageElement.style.display = 'none', 1000);
            }
        }
    }
}


window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    perspectiveCamera.aspect = window.innerWidth / window.innerHeight;
    perspectiveCamera.updateProjectionMatrix();

    const newAspect = window.innerWidth / window.innerHeight;
    orthographicCamera.left = viewSize * newAspect / -2;
    orthographicCamera.right = viewSize * newAspect / 2;
    orthographicCamera.updateProjectionMatrix();
});


// ì´ˆê¸° ëª¨ë“œ ì„¤ì •
setGameMode('MAKING');


// ê³„ì¸µì  ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
function animate() {
    // ë¯¹ì‹± ëª¨ì…˜ 
    if (gameMode === 'MAKING' && makingStep === 1) {
        mixingContent.rotation.y += 0.05;
    }

    // íšŒì „ (ê´€ëŒ ëª¨ë“œì—ì„œë§Œ)
    if (gameMode === 'VIEWING' && isToppingRotating) {
        const targetGroup = themeToppingGroup.visible ? themeToppingGroup : customToppingGroup;
        targetGroup.rotation.y += TOPPING_ROTATION_SPEED;
    }
    // ì¼€ì´í¬ ê·¸ë£¹ ì „ì²´ëŠ” í•­ìƒ ì²œì²œíˆ íšŒì „
    cakeGroup.rotation.y += BASE_ROTATION_SPEED;

    // ğŸš¨ ìŠ¤í”Œë˜ì‹œ ì´ë²¤íŠ¸ ì• ë‹ˆë©”ì´ì…˜ ì²˜ë¦¬
    const meshesToRemove = [];
    activeSplashMeshes.forEach(item => {
        item.timer++;
        const progress = item.timer / item.duration;
        
        const targetScale = 1.0 + Math.sin(progress * Math.PI) * 0.2; 
        item.mesh.scale.set(targetScale, targetScale, targetScale);
        
        if (item.timer >= item.duration) {
            item.mesh.scale.set(1.0, 1.0, 1.0); 
            meshesToRemove.push(item);
        }
    });

    meshesToRemove.forEach(item => {
        const index = activeSplashMeshes.indexOf(item);
        if (index > -1) activeSplashMeshes.splice(index, 1);
    });

    // ì´›ë¶ˆ ê¹œë¹¡ì„ íš¨ê³¼
    if (isCandleOn) {
        flame.scale.set(1 + Math.sin(Date.now() * 0.01) * 0.1, 1 + Math.sin(Date.now() * 0.01) * 0.1, 1);
        candleLight.intensity = 1.0 + Math.sin(Date.now() * 0.005) * 0.5; 
    }

    // ì¹´ë©”ë¼ê°€ í˜„ì¬ í™œì„±í™”ëœ ê·¸ë£¹ì„ ì‘ì‹œí•˜ë„ë¡ ì—…ë°ì´íŠ¸
    let target = cakeGroup.visible ? cakeGroup : bowlGroup;
    const targetPosition = new THREE.Vector3();
    target.getWorldPosition(targetPosition);

    if (currentCamera === perspectiveCamera) {
        currentCamera.lookAt(targetPosition);
    } else if (currentCamera === orthographicCamera) {
        currentCamera.lookAt(targetPosition);
    }

    renderer.render(scene, currentCamera);
}

renderer.setAnimationLoop(animate);
</script>

</body>
</html>