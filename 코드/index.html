<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js ì¼€ì´í¬ ì œì‘ ì‹œë®¬ë ˆì´ì…˜ & ê´€ëŒ - ìµœì¢…</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; }
        /* ê´€ëŒ ëª¨ë“œ ì»¨íŠ¸ë¡¤ UI */
        .controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 14px;
            z-index: 100;
            user-select: none;
            text-align: left;
        }
        .controls h3 { margin: 0 0 5px 0; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .controls p { margin: 3px 0; }
        .highlight { color: #3de6c5; font-weight: bold; }
        
        /* íŒ”ë ˆíŠ¸ ì»¨í…Œì´ë„ˆ */
        #palette-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: none; 
            padding: 15px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        #topping-palette, #cream-palette {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }
        .palette-item {
            width: 50px;
            height: 50px;
            border: 3px solid transparent;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            color: #333;
            transition: border-color 0.2s;
        }
        .palette-item:hover { border-color: #3de6c5; }
        .palette-item.selected { border-color: #3de6c5; }
        
        /* ë©”ì‹œì§€ ì°½ */
        #message {
            position: absolute;
            top: 100px; 
            left: 50%;
            transform: translateX(-50%);
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 10px;
            font-size: 20px;
            z-index: 101;
            display: block; 
            text-align: center;
            line-height: 1.5;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    
    <div id="message">
        ì¼€ì´í¬ ì œì‘ ì‹œë®¬ë ˆì´ì…˜ì„ ì‹œì‘í•©ë‹ˆë‹¤!<br>
        <span style="color: #3de6c5;">[Spacebar]</span>ë¥¼ ëˆŒëŸ¬ ë°˜ì£½ ë° ë¯¹ì‹± ê³¼ì •ì„ ì§„í–‰í•˜ì„¸ìš”.
    </div>

    <div id="palette-container">
        <div>ìƒí¬ë¦¼ ìƒ‰ìƒ ì„ íƒ (í´ë¦­ í›„ ì¼€ì´í¬ í´ë¦­)</div>
        <div id="cream-palette">
            <div class="palette-item selected" data-type="cream" data-color="0xffffff" style="background-color: #ffffff;">í°ìƒ‰</div>
            <div class="palette-item" data-type="cream" data-color="0xffc0cb" style="background-color: #ffc0cb;">í•‘í¬</div>
            <div class="palette-item" data-type="cream" data-color="0x5a8d41" style="background-color: #5a8d41;">ë…¹ì°¨</div>
            <div class="palette-item" data-type="cream" data-color="0xffd700" style="background-color: #ffd700;">ê³ êµ¬ë§ˆ</div>
        </div>
        <hr style="border-color: #444; margin: 10px 0;">
        <div>í† í•‘ ì„ íƒ (í´ë¦­ í›„ ì¼€ì´í¬ í´ë¦­)</div>
        <div id="topping-palette">
            <div class="palette-item" data-type="strawberry" style="background-color: #ffcccc;">ë”¸ê¸°</div>
            <div class="palette-item" data-type="sprinkle" style="background-color: #e0e0e0;">ìŠ¤í”„ë§í´</div>
            <div class="palette-item" data-type="drizzle" style="background-color: #a0522d;">ì´ˆì½œë¦¿</div>
            <div class="palette-item" data-type="cherry" style="background-color: #ff0000; color: white;">ì²´ë¦¬</div>
        </div>
    </div>

    <div id="viewing-controls" class="controls" style="display: none;">
        <h3>ğŸ‚ ê´€ëŒ ëª¨ë“œ ì»¨íŠ¸ë¡¤</h3>
        <p><span class="highlight">[P]</span> / <span class="highlight">[O]</span>: ì›ê·¼ / ì§êµ ì¹´ë©”ë¼ ì „í™˜</p>
        <p><span class="highlight">[â†‘] [â†“] [â†] [â†’]</span>: ì¼€ì´í¬ ì´ë™</p>
        <p><span class="highlight">[1]</span> / <span class="highlight">[2]</span>: ì¹´ë©”ë¼ ìœ„ì¹˜ ë³€ê²½</p>
        <p><span class="highlight">[L]</span>: ìŠ¤í¬íŠ¸ ì¡°ëª… ìƒ‰ìƒ & ê°•ë„ ë³€ê²½</p>
        <p><span class="highlight">[Spacebar]</span>: í† í•‘ íšŒì „/ì •ì§€</p>
        <p><span class="highlight">[C]</span>: ì´›ë¶ˆ ì¼œê¸°/ë„ê¸°</p>
        <hr style="border-color: #444; margin: 5px 0;">
        <p><span class="highlight">[K]</span>: ì¼€ì´í¬ ì „í™˜ (ì œì‘ â†” ë‹¤ìŒ í…Œë§ˆ)</p>
    </div>

<script>
// í•™ë²ˆ: 20230789
// ì´ë¦„: ë°°í¬ê²¸
// ì‚¬ìš©í•œ Three.js ë°©ë²•: CDN

const h_scr = window.innerWidth;
const v_scr = window.innerHeight;
const viewSize = 10; 
const aspect = h_scr / v_scr;
const moveSpeed = 0.1; 
const CAKE_HEIGHT = 1.0; 

const BASE_ROTATION_SPEED = 0.001;
const TOPPING_ROTATION_SPEED = 0.015;

const scene = new THREE.Scene(); 
scene.background = new THREE.Color(0xf0f0f0); 

// --- ëª¨ë“œ ë³€ìˆ˜ ---
let gameMode = 'MAKING'; 
let makingStep = 0; 
let selectedToppingType = null;
let selectedCreamColor = 0xffffff; // ì‚¬ìš©ì ì»¤ìŠ¤í…€ ì¼€ì´í¬ì˜ ìƒí¬ë¦¼ ìƒ‰ìƒ ì €ì¥ìš©

const mouse = new THREE.Vector2();
const raycaster = new THREE.Raycaster();

// --- HTML ìš”ì†Œ ---
const paletteContainer = document.getElementById('palette-container');
const messageElement = document.getElementById('message');
const controlsElement = document.getElementById('viewing-controls');

// --- 1. ì¹´ë©”ë¼ ì„¤ì • ---
const perspectiveCamera = new THREE.PerspectiveCamera(75, h_scr / v_scr, 0.1, 1000);
perspectiveCamera.position.set(0, 2.0, 4); 

const orthographicCamera = new THREE.OrthographicCamera(
    viewSize * aspect / -2, viewSize * aspect / 2, viewSize / 2, viewSize / -2, 0.1, 100
);
orthographicCamera.position.set(0, 5, 0);

let currentCamera = perspectiveCamera;
currentCamera.lookAt(0, 0, 0); 

// ë Œë”ëŸ¬ ì„¤ì •
const renderer = new THREE.WebGLRenderer({ antialias: true });
document.body.appendChild(renderer.domElement);
renderer.setSize(h_scr, v_scr);
renderer.shadowMap.enabled = true; 
renderer.shadowMap.type = THREE.PCFSoftShadowMap; 


// --- 2. ì¡°ëª… ì„¤ì • ---
const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); 
scene.add(ambientLight);

const spotLight = new THREE.SpotLight(0xffffff, 2.0, 10, Math.PI * 0.15, 0.5, 2); 
spotLight.position.set(2, 4, 3);
spotLight.castShadow = true;
spotLight.shadow.mapSize.width = 1024;
spotLight.shadow.mapSize.height = 1024;
scene.add(spotLight);

const frontLight = new THREE.DirectionalLight(0xffffff, 0.5);
frontLight.position.set(0, 3, 5);
frontLight.castShadow = true;
scene.add(frontLight);

const lightColors = [0xffffff, 0xf183f3, 0x3de6c5, 0xffa500]; 
let currentLightColorIndex = 0;

// --- 3. ì£¼ë°© í™˜ê²½ ì„¤ì • ---
const kitchenGroup = new THREE.Group();
scene.add(kitchenGroup);

const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
const wall = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), wallMaterial);
wall.rotation.y = Math.PI;
wall.position.set(0, 5, -5);
wall.receiveShadow = true;
kitchenGroup.add(wall);

const counterMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 }); 
const counter = new THREE.Mesh(new THREE.BoxGeometry(5, 1, 5), counterMaterial);
counter.position.set(0, -0.5, 0);
counter.receiveShadow = true;
kitchenGroup.add(counter);

const gridHelper = new THREE.GridHelper( 5, 5, 0x444444, 0x888888 );
scene.add( gridHelper );


// --- 4. ì¼€ì´í¬ ì œì‘/ëª¨ë¸ë§ ìš”ì†Œ ---

// ì¬ì§ˆ ì •ì˜
const batterMaterial = new THREE.MeshPhongMaterial({ color: 0xf4d03f, shininess: 10 }); 
// ğŸš¨ bakedMaterialì˜ ìƒ‰ìƒ ì½”ë“œ: 0xe0b28a
const bakedMaterial = new THREE.MeshPhongMaterial({ color: 0xe0b28a, shininess: 30 }); 
const creamMaterial = new THREE.MeshPhongMaterial({ color: selectedCreamColor, shininess: 80 }); 
const strawberryMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 50 }); 
const chocolateMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513, shininess: 20 }); 
const macaronMaterial = new THREE.MeshPhongMaterial({ color: 0xe0e0e0, shininess: 80 }); 
const beanMaterial = new THREE.MeshPhongMaterial({ color: 0x803333, shininess: 20 }); 


// 4-1. ë¯¹ì‹± ìš©ê¸°
const bowlGroup = new THREE.Group();
bowlGroup.position.y = 1.0;
scene.add(bowlGroup);
const bowl = new THREE.Mesh(
    new THREE.CylinderGeometry(2.0, 1.5, 1.0, 32, 1, true),
    new THREE.MeshStandardMaterial({ color: 0xcccccc, transparent: true, opacity: 0.3, side: THREE.BackSide })
);
bowl.position.y = 0.5;
bowlGroup.add(bowl);
const mixingContent = new THREE.Group();
const egg = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
const flour = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3), new THREE.MeshBasicMaterial({ color: 0xffffff }));
for(let i=0; i<30; i++) {
    const item = i % 5 === 0 ? egg.clone() : flour.clone();
    item.position.set((Math.random() - 0.5) * 2, Math.random() * 0.5, (Math.random() - 0.5) * 2);
    mixingContent.add(item);
}
mixingContent.position.y = 0.5;
mixingContent.visible = false;
bowlGroup.add(mixingContent);


// 4-2. ì¼€ì´í¬ ë³¸ì²´ (1ì¸µ)
const cakeGroup = new THREE.Group();
cakeGroup.position.y = 0.5; 
cakeGroup.visible = false; 
scene.add(cakeGroup);

const cakeLayerGeometry = new THREE.CylinderGeometry(1.5, 1.5, CAKE_HEIGHT, 32);

// ë¹µ ì¸µ
const cakeBody = new THREE.Mesh(cakeLayerGeometry, bakedMaterial);
cakeBody.position.y = 0; 
cakeBody.castShadow = true;
cakeBody.receiveShadow = true;
cakeGroup.add(cakeBody);

// ìƒí¬ë¦¼ ë ˆì´ì–´ (ì¼€ì´í¬ ìœ—ë©´)
const creamTop = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.1, 32), creamMaterial);
creamTop.position.y = CAKE_HEIGHT * 0.5 + 0.05; 
creamTop.castShadow = true;
creamTop.receiveShadow = true;
cakeGroup.add(creamTop);


// 4-3. í† í•‘ ê·¸ë£¹ (Custom, Theme)
const customToppingGroup = new THREE.Group();
customToppingGroup.position.y = 0.5 * CAKE_HEIGHT + 0.1;
cakeGroup.add(customToppingGroup);

const themeToppingGroup = new THREE.Group();
themeToppingGroup.position.y = 0.5 * CAKE_HEIGHT + 0.1;
cakeGroup.add(themeToppingGroup);
themeToppingGroup.visible = false; 

// --- ì´›ë¶ˆ (ëª¨ë“  ì¼€ì´í¬ì— í¬í•¨ë˜ë„ë¡ ì¼€ì´í¬ ê·¸ë£¹ì˜ ìì‹ìœ¼ë¡œ ìœ„ì¹˜) ---
const mainCandleGroup = new THREE.Group();
mainCandleGroup.position.set(0, CAKE_HEIGHT * 0.5 + 0.15, 0); 
cakeGroup.add(mainCandleGroup);

const candleBody = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.6, 16), new THREE.MeshPhongMaterial({ color: 0xffa500, shininess: 50 })); 
candleBody.position.y = 0.3; 
mainCandleGroup.add(candleBody);
const flame = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffc800, transparent: true, opacity: 0.8 })); 
flame.position.y = 0.65; 
mainCandleGroup.add(flame);
const candleLight = new THREE.PointLight(0xffaa00, 1.0, 2); 
candleLight.position.y = 0.7; 
mainCandleGroup.add(candleLight);

let isCandleOn = true;
candleLight.visible = isCandleOn;
flame.visible = isCandleOn;


// 4-4. í…Œë§ˆë³„ í† í•‘ (í…Œë§ˆ ê·¸ë£¹ì— ëª¨ë‘ ë°°ì¹˜)
const themeMeshes = new THREE.Group(); 
themeToppingGroup.add(themeMeshes); 

// ë”¸ê¸°
const strawberryMeshes = [];
[[1.0, 0], [-1.0, 0], [0.7, 0.7], [-0.7, 0.7], [0, -1.0]].forEach(pos => {
    const s = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), strawberryMaterial);
    s.position.set(pos[0], 0, pos[1]);
    themeMeshes.add(s);
    strawberryMeshes.push(s);
});

// ì´ˆì½œë¦¿ ë“œë¦¬ì¦
const chocolateDrizzle = new THREE.Mesh(new THREE.TorusKnotGeometry(1.3, 0.08, 64, 8, 2, 3), chocolateMaterial);
chocolateDrizzle.position.set(0, -0.15, 0); 
chocolateDrizzle.scale.set(1.0, 0.5, 1.0);
chocolateDrizzle.rotation.x = Math.PI / 2;
themeMeshes.add(chocolateDrizzle);

// ê³ êµ¬ë§ˆ
const sweetPotatoMeshes = [];
const sweetPotatoGeometry = new THREE.SphereGeometry(0.3, 16, 16);
[[0.5, 0.5, 0.8], [-0.5, 0.5, 1.2], [0, -0.7, 1.0], [1.0, -0.3, 0.9]].forEach(params => {
    const m = new THREE.Mesh(sweetPotatoGeometry, new THREE.MeshPhongMaterial({ color: 0xd7af70, shininess: 30 }));
    m.position.set(params[0], 0.1 + params[2] * 0.15, params[1]);
    m.scale.y = params[2];
    themeMeshes.add(m);
    sweetPotatoMeshes.push(m);
});

// ë…¹ì°¨ (ë§ˆì¹´ë¡±, íŒ¥)
const matchaMeshes = [];
const macaronGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 32);
[['macaron', 1.2, 0.5], ['macaron', -1.2, 0.5], ['macaron', 0.8, -0.9], 
 ['bean', 0.3, 0.9], ['bean', -0.4, 0.8], ['bean', 0.6, 0.1], ['bean', -0.8, -0.2], ['bean', 0.1, -0.6]]
.forEach(params => {
    let element;
    if (params[0] === 'macaron') {
        element = new THREE.Mesh(macaronGeometry, macaronMaterial);
        element.rotation.x = Math.PI / 2; 
    } else { 
        element = new THREE.Mesh(new THREE.SphereGeometry(0.1, 12, 12), beanMaterial);
    }
    element.position.set(params[1], 0.05, params[2]);
    themeMeshes.add(element);
    matchaMeshes.push(element);
});

// ìŠ¤í”„ë§í´ (í…Œë§ˆ ì „ìš©)
const themeSprinkleMeshes = [];
const sprinkleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.1, 8);
const sprinkleColors = [0xffa500, 0x00ff00, 0x0000ff, 0xff00ff, 0xffff00]; 
for (let i = 0; i < 50; i++) { 
    const material = new THREE.MeshPhongMaterial({ shininess: 100 });
    const sprinkle = new THREE.Mesh(sprinkleGeometry, material);
    const radius = Math.random() * 1.3;
    const angle = Math.random() * Math.PI * 2;
    sprinkle.position.set(Math.cos(angle) * radius, 0.05, Math.sin(angle) * radius);
    sprinkle.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
    themeMeshes.add(sprinkle);
    themeSprinkleMeshes.push(sprinkle);
}
themeMeshes.children.forEach(m => m.visible = false); 


// ë°”ë‹¥
const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), new THREE.MeshLambertMaterial({ color: 0xc8c8c8, side: THREE.DoubleSide }));
floor.rotation.x = -Math.PI / 2; 
floor.position.y = -1; 
floor.receiveShadow = true;
scene.add(floor);


// --- 5. ì¼€ì´í¬ ì¢…ë¥˜ ì •ì˜ ---
const CAKE_THEMES = [
    { body: 0x4a2c2a, cream: 0x7b3f00, topping: 'chocolate' }, 
    { body: 0xffe0e0, cream: 0xffffff, topping: 'strawberry' }, 
    { body: 0xc8a2c8, cream: 0xffd700, topping: 'sweetpotato' }, 
    { body: 0xc0c8a0, cream: 0x5a8d41, topping: 'matcha' } 
];
let currentThemeIndex = -1; 
let isToppingRotating = true;


function updateCakeTheme() {
    // 1. ì»¤ìŠ¤í…€ vs í…Œë§ˆ ëª¨ë“œ ì „í™˜
    if (currentThemeIndex === -1) { 
        // ğŸš€ ì»¤ìŠ¤í…€ ëª¨ë“œ:
        // ğŸš¨ ìˆ˜ì •: ë¹µ ëª¸í†µ ì¬ì§ˆì„ ì›ë˜ì˜ bakedMaterialë¡œ ë˜ëŒë¦¬ê³ , ìƒ‰ìƒë„ ëª…ì‹œì ìœ¼ë¡œ ì¬ì„¤ì •í•©ë‹ˆë‹¤.
        cakeBody.material = bakedMaterial;
        cakeBody.material.color.set(0xe0b28a); // ì—°ì£¼í™ìƒ‰ìœ¼ë¡œ ëª…ì‹œì  ì¬ì„¤ì •
        
        // ì´ì „ì— ì €ì¥ëœ ìƒí¬ë¦¼ ìƒ‰ìƒìœ¼ë¡œ ë³µì›
        creamTop.material.color.set(selectedCreamColor); 
        
        customToppingGroup.visible = true;
        themeToppingGroup.visible = false;
        
    } else {
        // í…Œë§ˆ ëª¨ë“œ
        const theme = CAKE_THEMES[currentThemeIndex];
        const toppingType = theme.topping;
        
        // í…Œë§ˆ ë¹µ ìƒ‰ìƒ ì ìš© (ìƒ‰ìƒë§Œ ë³€ê²½)
        cakeBody.material.color.set(theme.body);
        // í…Œë§ˆ ìƒí¬ë¦¼ ìƒ‰ìƒ ì ìš©
        creamTop.material.color.set(theme.cream);
        
        customToppingGroup.visible = false;
        themeToppingGroup.visible = true;
        
        // í…Œë§ˆë³„ í† í•‘ ê°€ì‹œì„± ì¡°ì ˆ
        themeMeshes.children.forEach(m => m.visible = false);
        strawberryMeshes.forEach(s => s.visible = toppingType === 'strawberry');
        chocolateDrizzle.visible = toppingType === 'chocolate';
        sweetPotatoMeshes.forEach(s => s.visible = toppingType === 'sweetpotato');
        matchaMeshes.forEach(s => s.visible = toppingType === 'matcha');
        
        // ìŠ¤í”„ë§í´ ìƒ‰ìƒ ë³€ê²½ (í…Œë§ˆ í† í•‘ì¼ ë•Œë§Œ ë³´ì´ë„ë¡ ì„¤ì •)
        themeSprinkleMeshes.forEach((s, i) => {
            s.visible = true; // í…Œë§ˆ ëª¨ë“œì¼ ë•Œ ìŠ¤í”„ë§í´ ë³´ì´ê²Œ ì„¤ì •
            const material = s.material;
            if (toppingType === 'matcha') material.color.set(Math.random() > 0.5 ? 0x90ee90 : 0xffffff);
            else if (toppingType === 'sweetpotato') material.color.set(0x8b4513);
            else material.color.set(sprinkleColors[i % sprinkleColors.length]);
            material.needsUpdate = true;
        });
    }

    // 5. ì¬ì§ˆ ì—…ë°ì´íŠ¸ ìš”ì²­
    cakeBody.material.needsUpdate = true;
    creamTop.material.needsUpdate = true;
}


// --- 6. ëª¨ë“œ ì „í™˜ ë° ì œì‘ ë‹¨ê³„ ë¡œì§ ---

function setGameMode(mode) {
    gameMode = mode;
    messageElement.style.display = 'none';
    paletteContainer.style.display = 'none';
    controlsElement.style.display = 'none';
    bowlGroup.visible = false;
    cakeGroup.visible = false;
    
    mainCandleGroup.visible = true;
    candleLight.visible = isCandleOn;
    flame.visible = isCandleOn;

    if (mode === 'MAKING') {
        bowlGroup.visible = true;
        cakeBody.visible = false;
        creamTop.visible = false;
        messageElement.innerHTML = `ì¼€ì´í¬ ì œì‘ ì‹œë®¬ë ˆì´ì…˜ì„ ì‹œì‘í•©ë‹ˆë‹¤!<br><span style="color: #3de6c5;">[Spacebar]</span>ë¥¼ ëˆŒëŸ¬ ë°˜ì£½ ë° ë¯¹ì‹± ê³¼ì •ì„ ì§„í–‰í•˜ì„¸ìš”.`;
        messageElement.style.display = 'block';
        makingStep = 0;
        mixingContent.visible = false;
        mixingContent.children.forEach(m => m.material.color.set(m.geometry.type === 'SphereGeometry' ? 0xffaa00 : 0xffffff)); 
    } else if (mode === 'DECORATING') {
        cakeGroup.visible = true;
        cakeBody.visible = true;
        creamTop.visible = true;

        messageElement.innerHTML = `ì¥ì‹ ëª¨ë“œ: ì•„ë˜ íŒ”ë ˆíŠ¸ì—ì„œ <span class="highlight">ìƒí¬ë¦¼ ìƒ‰ìƒ</span> ë˜ëŠ” <span class="highlight">í† í•‘</span>ì„ ì„ íƒ í›„ ì¼€ì´í¬ ìœ—ë©´ì„ <span class="highlight">í´ë¦­</span>í•˜ì—¬ ì ìš©í•˜ì„¸ìš”.<br>ì™„ë£Œ í›„ <span style="color: #3de6c5;">[Enter]</span> í‚¤ë¥¼ ëˆ„ë¥´ì„¸ìš”.`;
        messageElement.style.display = 'block';
        paletteContainer.style.display = 'block';
        customToppingGroup.visible = true;
        themeToppingGroup.visible = false;
        
        // DECORATING ëª¨ë“œ ì§„ì… ì‹œ ìƒí¬ë¦¼ ìƒ‰ìƒì„ í°ìƒ‰ìœ¼ë¡œ ì´ˆê¸°í™”
        creamTop.material.color.set(0xffffff); 
        selectedCreamColor = 0xffffff;
        
        document.querySelectorAll('.palette-item').forEach(i => i.classList.remove('selected'));
        document.querySelector('.palette-item[data-color="0xffffff"]').classList.add('selected');
    } else if (mode === 'VIEWING') {
        cakeGroup.visible = true;
        cakeBody.visible = true;
        creamTop.visible = true;

        controlsElement.style.display = 'block';
        
        // VIEWING ëª¨ë“œ ì§„ì… ì‹œ (DECORATING ì™„ë£Œ í›„) 
        // í˜„ì¬ ì»¤ìŠ¤í…€ ì¼€ì´í¬ì˜ ìƒí¬ë¦¼ ìƒ‰ìƒì„ selectedCreamColorì— ì €ì¥
        selectedCreamColor = creamTop.material.color.getHex(); 
        
        currentThemeIndex = -1; 
        updateCakeTheme();
    }
}

function advanceMakingStep() {
    makingStep++;

    if (makingStep === 1) { 
        mixingContent.visible = true;
        messageElement.innerHTML = `ë¯¹ì‹±: ê³„ë€, ë°€ê°€ë£¨, ì„¤íƒ•ì„ ë„£ê³  ìˆìŠµë‹ˆë‹¤.<br> <span style="color: #3de6c5;">[Spacebar]</span>ë¡œ ë°˜ì£½ì„ ì™„ë£Œí•˜ì„¸ìš”.`;
    } else if (makingStep === 2) { 
        mixingContent.children.forEach(m => m.material.color.set(0xf4d03f));
        messageElement.innerHTML = `ë°˜ì£½ ì™„ë£Œ! ì˜¤ë¸ì— êµ¬ìš¸ ì¤€ë¹„ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.<br> <span style="color: #3de6c5;">[Spacebar]</span>ë¡œ êµ½ê¸°ë¥¼ ì‹œì‘í•˜ì„¸ìš”.`;
    } else if (makingStep === 3) { 
        bowlGroup.visible = false;
        cakeGroup.visible = true;
        cakeBody.visible = true;
        creamTop.visible = true;
        // ğŸš¨ ìˆ˜ì •: êµ½ê¸° ì™„ë£Œ ì‹œ ë¹µ ëª¸í†µ ìƒ‰ìƒì„ ì´ˆê¸° bakedMaterialì˜ ìƒ‰ìƒìœ¼ë¡œ ëª…ì‹œì ìœ¼ë¡œ ì„¤ì •
        cakeBody.material = bakedMaterial; 
        cakeBody.material.color.set(0xe0b28a); // ì—°ì£¼í™ìƒ‰
        
        messageElement.innerHTML = `êµ½ê¸° ì™„ë£Œ ë° ì ì¸µ! ì´ì œ ì¥ì‹í•©ë‹ˆë‹¤.<br> <span style="color: #3de6c5;">[Spacebar]</span>ë¡œ ì¥ì‹ ëª¨ë“œì— ì§„ì…í•˜ì„¸ìš”.`;
    } else if (makingStep === 4) { 
        setGameMode('DECORATING');
    }
}


window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();

    // ì œì‘ ëª¨ë“œ (MAKING) ì»¨íŠ¸ë¡¤
    if (gameMode === 'MAKING' && k === ' ') {
        advanceMakingStep();
        return;
    }

    // ì¥ì‹ ëª¨ë“œ (DECORATING) ì»¨íŠ¸ë¡¤
    if (gameMode === 'DECORATING' && e.key === 'Enter') {
        setGameMode('VIEWING');
        return;
    }
    
    // 3. ê´€ëŒ ëª¨ë“œ (VIEWING) ì»¨íŠ¸ë¡¤
    if (gameMode !== 'VIEWING') return;

    // í…Œë§ˆ ì¼€ì´í¬ ì „í™˜: K í‚¤
    if (k === 'k') {
        if (currentThemeIndex === -1) { 
            // ì»¤ìŠ¤í…€ ëª¨ë“œì—ì„œ í…Œë§ˆ ëª¨ë“œë¡œ ì „í™˜ ì§ì „ì— í˜„ì¬ ìƒ‰ìƒ ì €ì¥
            selectedCreamColor = creamTop.material.color.getHex(); 
            currentThemeIndex = 0; 
        } else {
            currentThemeIndex++;
            if (currentThemeIndex >= CAKE_THEMES.length) {
                currentThemeIndex = -1; // ì»¤ìŠ¤í…€ ëª¨ë“œë¡œ ëŒì•„ê°€ê¸°
            }
        }
        updateCakeTheme();
    }
    
    // ì¡°ëª… ìƒ‰ìƒ ë³€ê²½: L í‚¤
    if (k === 'l') {
        currentLightColorIndex = (currentLightColorIndex + 1) % lightColors.length;
        const newColor = lightColors[currentLightColorIndex];
        spotLight.color.set(newColor);
        frontLight.color.set(newColor); 
        spotLight.intensity = (currentLightColorIndex === 0) ? 2.0 : 1.5;
    }

    // ì¹´ë©”ë¼ ìœ„ì¹˜ ë³€ê²½: 1/2 í‚¤
    if (k === '1' || k === '2') {
        const targetPosition = new THREE.Vector3();
        cakeGroup.getWorldPosition(targetPosition); 
        
        if (k === '1') { // ì¸¡ë©´ ìƒ·
            perspectiveCamera.position.set(targetPosition.x + 4, targetPosition.y + 1, targetPosition.z);
        } else if (k === '2') { // ì •ë©´ ìƒ· (ì•½ê°„ ìœ„ì—ì„œ)
            perspectiveCamera.position.set(targetPosition.x, targetPosition.y + 3, targetPosition.z + 5);
        }

        currentCamera = perspectiveCamera;
        currentCamera.lookAt(targetPosition); 
        currentCamera.updateProjectionMatrix();
        return;
    }

    // ì¹´ë©”ë¼, ì´ë™, íšŒì „, ì´›ë¶ˆ ë“± ë‚˜ë¨¸ì§€ ê´€ëŒ ì»¨íŠ¸ë¡¤
    if (k === 'p') currentCamera = perspectiveCamera; 
    else if (k === 'o') currentCamera = orthographicCamera; 
    currentCamera.updateProjectionMatrix();

    if (e.key === 'ArrowUp') cakeGroup.position.z -= moveSpeed; 
    else if (e.key === 'ArrowDown') cakeGroup.position.z += moveSpeed;
    else if (e.key === 'ArrowLeft') cakeGroup.position.x -= moveSpeed;
    else if (e.key === 'ArrowRight') cakeGroup.position.x += moveSpeed;
    
    if (k === ' ') isToppingRotating = !isToppingRotating;

    if (k === 'c') {
        isCandleOn = !isCandleOn;
        candleLight.visible = isCandleOn;
        flame.visible = isCandleOn;
    }

    if (e.key.startsWith('Arrow')) e.preventDefault();
});


// --- 7. ì¥ì‹ ëª¨ë“œ í´ë¦­ ë° íŒ”ë ˆíŠ¸ ë¡œì§ ---

document.querySelectorAll('.palette-item').forEach(item => {
    item.addEventListener('click', () => {
        if (gameMode !== 'DECORATING') return;
        
        document.querySelectorAll('.palette-item').forEach(i => i.classList.remove('selected'));
        item.classList.add('selected');
        
        const type = item.dataset.type;
        if (type === 'cream') {
            selectedToppingType = null;
            selectedCreamColor = parseInt(item.dataset.color);
        } else {
            selectedToppingType = type;
            selectedCreamColor = 0; 
        }
    });
});

window.addEventListener('click', onDecoratingClick);

function onDecoratingClick(event) {
    if (gameMode !== 'DECORATING') return;
    
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, currentCamera);
    
    const intersects = raycaster.intersectObject(creamTop); 
    
    if (intersects.length > 0) {
        if (selectedCreamColor) {
            // ìƒí¬ë¦¼ ìƒ‰ìƒ ë³€ê²½ ì‹œ ì¬ì§ˆ ì—…ë°ì´íŠ¸
            creamTop.material.color.set(selectedCreamColor);
            creamTop.material.needsUpdate = true;
            
        } else if (selectedToppingType) {
            // í† í•‘ ì¶”ê°€
            const point = intersects[0].point;
            const distance = new THREE.Vector2(point.x, point.z).length();
            const maxRadius = 1.3;
            
            if (distance <= maxRadius) {
                let newTopping;

                if (selectedToppingType === 'drizzle') {
                    if (customToppingGroup.children.some(c => c.name === 'drizzle')) return;
                    newTopping = new THREE.Mesh(new THREE.TorusKnotGeometry(1.3, 0.08, 64, 8, 2, 3), chocolateMaterial);
                    newTopping.position.set(0, -0.15, 0); 
                    newTopping.scale.set(1.0, 0.5, 1.0);
                    newTopping.rotation.x = Math.PI / 2;
                    newTopping.name = 'drizzle';
                } else if (selectedToppingType === 'strawberry') {
                    newTopping = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), strawberryMaterial);
                    newTopping.position.set(point.x, 0.05, point.z);
                } else if (selectedToppingType === 'sprinkle') {
                    const color = sprinkleColors[Math.floor(Math.random() * sprinkleColors.length)];
                    const material = new THREE.MeshPhongMaterial({ color: color, shininess: 100 });
                    newTopping = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.1, 8), material);
                    newTopping.position.set(point.x, 0.05, point.z);
                    newTopping.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                } else if (selectedToppingType === 'cherry') {
                    newTopping = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), new THREE.MeshPhongMaterial({ color: 0xcc0000, shininess: 50 }));
                    newTopping.position.set(point.x, 0.05, point.z);
                    const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8), new THREE.MeshBasicMaterial({ color: 0x442200 }));
                    stem.position.y = 0.1;
                    newTopping.add(stem);
                }
                
                if (newTopping) {
                    newTopping.castShadow = true;
                    customToppingGroup.add(newTopping);
                }
            }
        }
    }
}


window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    perspectiveCamera.aspect = window.innerWidth / window.innerHeight;
    perspectiveCamera.updateProjectionMatrix();

    const newAspect = window.innerWidth / window.innerHeight;
    orthographicCamera.left = viewSize * newAspect / -2;
    orthographicCamera.right = viewSize * newAspect / 2;
    orthographicCamera.updateProjectionMatrix();
});


// ì´ˆê¸° ëª¨ë“œ ì„¤ì •
setGameMode('MAKING');


// ê³„ì¸µì  ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
function animate() {
    // ë¯¹ì‹± ëª¨ì…˜ 
    if (gameMode === 'MAKING' && makingStep === 1) {
        mixingContent.rotation.y += 0.05;
    }

    // íšŒì „ (ê´€ëŒ ëª¨ë“œì—ì„œë§Œ)
    if (gameMode === 'VIEWING' && isToppingRotating) {
        const targetGroup = themeToppingGroup.visible ? themeToppingGroup : customToppingGroup;
        targetGroup.rotation.y += TOPPING_ROTATION_SPEED;
    }
    // ì¼€ì´í¬ ê·¸ë£¹ ì „ì²´ëŠ” í•­ìƒ ì²œì²œíˆ íšŒì „
    cakeGroup.rotation.y += BASE_ROTATION_SPEED;

    // ì´›ë¶ˆ ê¹œë¹¡ì„ íš¨ê³¼
    if (isCandleOn) {
        flame.scale.set(1 + Math.sin(Date.now() * 0.01) * 0.1, 1 + Math.sin(Date.now() * 0.01) * 0.1, 1);
        candleLight.intensity = 1.0 + Math.sin(Date.now() * 0.005) * 0.5; 
    }

    // ì¹´ë©”ë¼ê°€ í˜„ì¬ í™œì„±í™”ëœ ê·¸ë£¹ì„ ì‘ì‹œí•˜ë„ë¡ ì—…ë°ì´íŠ¸
    let target = cakeGroup.visible ? cakeGroup : bowlGroup;
    const targetPosition = new THREE.Vector3();
    target.getWorldPosition(targetPosition);

    if (currentCamera === perspectiveCamera) {
        currentCamera.lookAt(targetPosition);
    } else if (currentCamera === orthographicCamera) {
        currentCamera.lookAt(targetPosition);
    }

    renderer.render(scene, currentCamera);
}

renderer.setAnimationLoop(animate);
</script>

</body>
</html>